text
"ptg45047941

From the Library of Tos Chaiwong

xxx Cisco pyATS—Network Test and Automation Solution

Introduction

This book was written to explore the powerful capabilities of automated network test- ing with the Cisco pyATS framework. Network testing and validation is a low-risk, yet powerful domain in the network automation space. This book is organized to address the multiple features of pyATS and the pyATS library (Genie). Readers will learn why network testing and validation are important, how pyATS can be leveraged to run tests against network devices, and how to integrate pyATS into larger workflows using CI/CD pipelines and artificial intelligence (AI)."
"Goals and Objectives

This book touches on many aspects of network automation, including device configu- ration, data parsing, APIs, parallel programming, artificial intelligence, and, of course, automated network testing. The intended audience for this book is network profession- als and software developers wanting to learn more about the pyATS framework and the benefits of automated network testing. The audience should be comfortable with Python, as pyATS is built with the Python programming language.

Candidates who are looking to learn pyATS as it relates to the Cisco DevNet Expert Lab exam will find the use cases and examples throughout the book valuable for exam preparation."
"How This Book Is Organized

Chapter 1, “Foundations of NetDevOps”: This chapter introduces NetDevOps, outlin- ing its benefits and how it merges with software development methodologies to enhance network automation. We compare key automation tools and detail the modern network engineer’s toolkit, setting the stage for applying NetDevOps in practice.

Chapter 2, “Installing and Upgrading pyATS”: The chapter shows how to install and upgrade pyATS and the pyATS library using Python package management tools and built- in pyATS commands.

Chapter 3, “Testbeds”: This chapter covers YAML’s basics, explores the concept of a testbed, and examines device connection abstractions. We discuss methods for testbed validation, the creation of dynamic testbeds, and how intent-based networking integrates with extended testbeds, providing a roadmap for their practical application."
"Chapter 4, “AEtest Test Infrastructure”: This chapter is one of the key chapters in this book. It goes in depth and reviews the different components that make up AEtest, the testing infrastructure that is the core of pyATS. Everything from defining testcases and individual test sections to running testscripts is covered in this chapter. After reading this chapter, you’ll understand how to introduce test inputs and parameters, define test sections, control the flow of test execution, and review test results with the built-in reporting features.

ptg45047941

From the Library of Tos Chaiwong"
"xxxi

Chapter 5, “pyATS Parsers”: This chapter delves into pyATS parsers, emphasizing vendor-neutral automation strategies. It covers the essentials of pyATS learn and parse features, techniques for CLI parsing, and parsing with Python. Additionally, we explore how to perform dictionary queries and analyze differentials, equipping you with the nec- essary skills for effective network data handling.

Chapter 6, “Test-Driven Development”: This chapter introduces test-driven develop- ment (TDD), its application in network automation, and an overview of pyATS. It further explores the pyATS framework, setting the foundation for incorporating TDD practices into network management."
"Chapter 7, “Automated Network Documentation”: This chapter explores automated net- work documentation, beginning with an introduction to pyATS jobs. It details executing pyATS jobs from the command-line interface (CLI), interpreting CLI logs, and utilizing the pyATS logs HTML viewer for enhanced analysis. We also delve into Jinja2 templating for document creation, culminating in the generation of business-ready documents.

Chapter 8, “Automated Network Testing”: This pivotal chapter delves into automated network testing, the core focus of the book. It outlines a strategic approach to network testing, including software version testing, interface testing, neighbor testing, and reach- ability testing. Additionally, we explore intent-validation testing and feature testing, essential components for ensuring network reliability and performance."
"Chapter 9, “pyATS Triggers and Verifications”: This chapter reviews how to use triggers and verifications using the Genie Harness. Triggers and verifications allow you to build dynamic testcases, with a low-code approach, that can change with your network requirements.

Chapter 10, “Automated Configuration Management”: In this chapter we will look at how to generate intent-based configuration using data models, Jinja2 templates, and Genie Conf objects. In addition to generating configurations, we will see how to push configuration to network devices using a file transfer server, Genie Conf objects, and pyATS device APIs.

Chapter 11, “Network Snapshots”: This chapter looks at how to profile the network by creating and comparing snapshots of the network. Network snapshots can be helpful when you’re troubleshooting a network issue or just learning about the network’s operat- ing state at a point in time."
"Chapter 12, “Recordings, Playbacks, and Mock Devices”: This chapter introduces pyATS recordings, covering the recording of pyATS jobs and the playback of these recordings. It explains how to create mock devices and simulate device interactions through the mock device CLI, offering practical insights into testing without the need for live network equipment.

Chapter 13, “Working with Application Programming Interfaces (API)”: This chapter focuses on working with pyATS APIs, detailing the pyATS API framework, REST connector, YANG connector, and gNMI. It provides insights into how these tools and protocols can be utilized for efficient network automation and management through API interactions.

ptg45047941

From the Library of Tos Chaiwong"
"xxxii Cisco pyATS—Network Test and Automation Solution

Chapter 14, “Parallel Call (pcall)”: Testing in pyATS can be sped up using parallel processing (parallelism). In this chapter, we review the differences between parallelism and concurrency using asynchronous programming. Parallel call (pcall) in pyATS enables parallel execution and is built on the multiprocessing package in the Python standard library.

Chapter 15, “pyATS Clean”: In this chapter, you will see how pyATS can reset devices during or after testing using the pyATS Clean feature.

Chapter 16, “pyATS Blitz”: In this chapter, we will review pyATS Blitz, which creates a low-code approach to building pyATS testcases using YAML syntax."
"Chapter 17, “Chatbots with Webex”: This chapter explores integrating pyATS with Webex, including pyATS job and health check integrations. It delves into using Adaptive Cards within Webex for interactive content and outlines methods for setting up custom- ized job notifications, enhancing communication and monitoring in network operations.

Chapter 18, “Running pyATS as a Container”: This chapter introduces the concept of containers, focusing on the pyATS official Docker container. It guides you through the pyATS image builder and details the process of building a pyATS image from scratch, offering a comprehensive approach to deploying pyATS as a containerized application.

Chapter 19, “pyATS Health Check”: This chapter dives into the different health checks that run to ensure devices under testing are operating correctly. Built-in health checks include checking CPU, memory, logging, and the presence of core dump files to ensure devices haven’t malfunctioned or crashed during testing."
"Chapter 20, “XPRESSO”: This section covers pyATS XPRESSO, starting with installa- tion instructions. It provides a beginner’s guide to getting started with XPRESSO and details on running pyATS jobs within the XPRESSO environment, facilitating an easy entry into utilizing this powerful tool.

Chapter 21, “CI/CD with pyATS”: The concept of CI/CD is a common practice in soft- ware development to build and test code before it’s pushed to production. In this chapter, we see how to use multiple network automation tools, including GitLab, Ansible, and pyATS, to apply CI/CD practices when pushing configuration changes to the network."
"Chapter 22, “Robot Framework”: In this chapter, we review Robot Framework, an open- source test automation framework. Robot Framework allows you to use English-like keywords to define testcases. After we review Robot Framework, we see how the pyATS libraries—Unicon, pyATS, and the pyATS library (Genie)—are integrated into Robot Framework by providing test libraries that include keywords to interact with network devices and define testcases.

Chapter 23, “Leveraging Artificial Intelligence in pyATS”: This chapter explores the integration of pyATS with artificial intelligence, focusing on leveraging the OpenAI API for enhanced network automation. It discusses the use of retrieval augmented genera- tion (RAG) with Langchain for intelligent data handling and introduces rapid prototyping with Streamlit, showcasing the potential for AI to revolutionize network management processes.

ptg45047941

From the Library of Tos Chaiwong"
"xxxiii

Appendix A, “Writing Your Own Parser”: This appendix covers how to contribute to the genieparser library (https://github.com/CiscoTestAutomation/genieparser) by creating a new parser for a Cisco IOS XE show command.

Appendix B, “Secret Strings”: This appendix covers how to protect the sensitive data in your testbed.yaml files through secret strings.

Credits

Figure 1.1: chinnappa/123RF

Figures 5.2a, 5.7-5.9, 5.13, 5.14, 13.2a, 21.1, AppA 1, 2, 4-7: GitHub, Inc

Figures 5.15-5.17, 7.24-7.34: Microsoft Corporation

Figure 20.26a: Jenkins

Figures 21.3, 21.4: GitLab B.V.

Figures 23.3-23.6: Snowflake Inc

ptg45047941

From the Library of Tos Chaiwong

Chapter 1

Foundations of NetDevOps"
"The landscape of enterprise networking has changed dramatically over the past several years with an explosion of new tools, technologies, and methodologies for building and operating networks at any scale. Network automation and programmability have also matured to the point that the expectation is that modern solutions are designed and implemented with an automate-first, agile mindset. Networks today are undergoing an evolution similar to that of voice networks two decades ago with command-line interfac- es and manual effort. Networks are rapidly being replaced with automation and program- mability. Network engineers now must consider software development practices when planning, designing, building, and operating networks in their day-to-day activities. Gone are the days of manually drafting device-to-device configurations; the focus is now on a more holistic, software-driven, automated vision of network design, configuration, and testing. Methodologies and practices in NetDevOps are adopted and adapted"
"from the broader DevOps movement, extending these practices to the network domain. Network automation and programmability are no longer the future—they are the present, and Python Automated Test Systems, or pyATS (pronounced py A-T-S), is crucial to acceler- ating your NetDevOps. pyATS was originally created by Jean-Benoit Aubin and Siming Yuan for internal Cisco testing, which has evolved into a free, public, mass-adoption net- work automation framework. Welcome to test-driven automation with Cisco pyATS; your transformative journey with pyATS begins here."
"This chapter covers the following topics:

■ Traditional network operations

■ Software development methodologies

■ Comparing network automation tools

■ The modern network engineer toolkit

ptg45047941

From the Library of Tos Chaiwong

2 Chapter 1: Foundations of NetDevOps

Traditional Network Operations"
"Historically, networks were predominantly driven by manual, human-centric efforts, although this did not undermine the significance of core principles, best practices, and foundational designs crucial for well-implemented and well-operated networks. With nearly 50 years of experience in the networking realm, the OSI and TCP/IP models remain relevant. Individuals boasting profound knowledge, expertise, and industry certi- fications often transition seamlessly into adept NetDevOps developers, as they meld their networking prowess with the contemporary tools and technologies essential for automa- tion. However, the journey of automation wasn’t straightforward. Initially, operations lev- eraged various tools for monitoring and managing configurations. These tools, primarily element managers, were adept at scrutinizing the active status of elements but fell short of monitoring the systems as a cohesive whole. Automation at a larger scale was a pre- rogative of those who could afford the coding outlay, as the high"
"costs stemmed from the lack of standardized interfaces on vendor equipment and high-level language support. The business case for automation was hard to justify without a substantial scale that could offset the high initial costs. Fast-forward to recent times, the landscape has evolved favorably. Vendors have lowered the entry barriers by prioritizing their APIs, and the widespread support for languages like Python has catalyzed the adoption of automation technologies. Transitioning from a purely network-centric career to a hybrid developer role now entails a lesser extent of training and learning, thanks to the improved accessi- bility and support for automation tools. The ensuing sections delve into the typical duties of a network engineer and the application of these skills within the NetDevOps frame- work, reflecting the changes brought about by the more accessible automation solutions."
"Architecture

The overall architecture of the network will still be required to establish the desired outcomes. Appropriate hardware selection for the physical layer of the network and the underlying connectivity model are vital to driving the design of the network. Architects also establish the best practices, validate designs, and work with vendors in product selection. These network architects are typically responsible for the overall network, handle high-level escalations, contribute to change management boards to review and approve operational changes, and interface with the enterprise leadership and manage- ment teams to establish roadmaps and long-term planning. Ancillary appliances that supply wireless access and identity, automation or software-defined network (SDN) controllers, and other required tools are necessary to meet the service level agreements (SLAs) and business requirements."
"The modern high-level designs also often include the selection of closed- and open- source tools required to operate and monitor the network. A greenfield network requires a lot of planning, and network architects don’t work in silos; in fact, there is often a great deal of collaboration with the vendor’s experts and specialists, the Internet service pro- vider (ISP), the chief technology officer (CTO), the chief information officer (CIO), and the chief information security officer (CISO) to translate business requirements, budgets, and SLAs. Ultimately, the network’s purpose is to connect people with their systems and

ptg45047941

From the Library of Tos Chaiwong"
"Traditional Network Operations 3

applications. Business needs are fulfilled by these applications and people, which in turn are underpinned by the network. Typically, the architect best understands the desired state, the expected baseline performance and services offered, and is an escalation point in the event of any unexpected issues or behaviors. In a modern NetDevOps environ- ment, the architect often plays the role of the senior developer over the network. Code reviews, approving the merging of code via Git pull requests, developing or refactoring network automation code, ensuring the quality of continuous integration/continuous development (CI/CD) pipelines, holding daily standups, and playing a role in scrum teams are all additional expectations of the modern network architect, beyond being a highly certified and capable network engineer.

High-Level Design"
"After an architecture has been established, a high-level design is created, which is often a visual representation of the network. Various blocks of the modular architecture are connected and east-west traffic flows (that is, traffic remaining with a module horizon- tally) and north-south traffic flows (that is, traffic leaving a module northbound toward the public Internet and network egress to the ISP or southbound into the data center) are determined. Various protocols, network zoning (security perimeters and boundar- ies), layer-one interconnections, and levels of redundancy are visualized into a high-level design. The speeds of interconnections, optics and cabling types, wireless standards, and access point placement are also part of the high-level design. The architects or designated designers carry out these tasks, and the designs are often validated by the collaborative architecture teams. Vendor-validated designs, request for comments (RFCs), and industry best practices are used as reference models"
"during the high-level design phase. Important artifacts such as the IP address scheme, network protocol design (such as OSPF areas, if OSPF is the selected routing protocol), and service requirements (Power over Ethernet [PoE] and 802.1x) accompany the high-level design. The high-level design should be a living document that evolves and changes as the network goes through its operational lifecycle in a continuous feedback loop."
Low-Level Design
"Lower-level designs overlay the actual configuration derived from the high-level design. Internet addresses are assigned as subnets to areas of the network, and individual inter- faces are assigned addresses. Routing and security protocol configurations are drafted as traffic flows are enforced across the network. The various spanning trees are mapped out and configurations established to ensure a loop-free topology with limited sized broadcast domains (VLANs). Redundant links are appropriately configured as inter- faces are bundled and routers are set up in highly redundant pairs. Usually, low-level designs are developed outward from the center of the network. The vital high-speed backbone and core routing configurations are developed first with north-south traffic in mind. Distribution and aggregation layers, also typically routed, are drafted next, followed by access port configurations established for edge features like power, iden- tity, security, and aggregation in the data center. Uplink port"
configuration standards
"ptg45047941

From the Library of Tos Chaiwong

4 Chapter 1: Foundations of NetDevOps"
"are developed, and the Layer 2/Layer 3 boundaries are established. Firewalls, access control lists (ACLs), and other security boundaries are implemented. Load balancing, wireless controllers, access and identities, and other ancillary service configurations are also included in lower-level designs. Low-level designs are often impacted the most by NetDevOps because not only do the high-level designs have to be transformed into working functional models of the network configurations, but these configurations also need to be transformed into objects that can be used for programming and automation. Data models, such as YANG, configuration templates, tests, intended configurations, and code to push the initial images and day 0 configurations to the greenfield devices also need to be included as artifacts in the low-level design. There is also a growing popularity in virtual eXtensible LAN (VXLAN) technologies expanding on Layer 2 connectivity in the enterprise (software-defined access), data center"
"(application-centric infrastructure/Nexus), and WAN networks (SD-WAN), adding even more to consider in the design phase of the modern network."
Day–1
"Day–1 (day minus one) activities include the translation of business requirements into functional network building blocks, including creating initial architectures, high- and low-level designs, and topology diagrams. Procuring hardware and associated software licenses, establishing SLAs with the business, vendors, and supporting third parties, and preparing internal processes, procedures, and support models are all part of day–1 activities in preparation for standing up the network. All activities prior to actual device onboarding can be described as day–1 activity where enterprises prepare to deploy their new network. In this phase, the enterprise typically gathers the recommended software image releases from the Internet as well as transforms low-level designs into initial device configurations. These device configurations are typically the bare minimum to get a device up and running and often require design and operational knowledge of what will be connected to the device. Information is often entered via"
"serial connection to the man- agement console of each device using the serial number to identify the placement of the device in the new network. Day–1 configurations are prerequisite configurations in order to establish a minimum level of off-device connectivity, such as the hostname, VTY line configurations, a username and enable secret, possibly hostname resolution (DNS), and cryptography (SSH keys). A manual mapping from an IP address management (IPAM) and low-level design is often performed by a human operator who applies a minimal base con- nectivity, enabling configuration from a template of some kind or individual instructions per device. Often these configurations are performed in the central warehouse or location where the devices have been received from the vendor shipping them. Devices are poten- tially barcoded and their serial and part numbers recorded. Stacks of devices are often assembled and the basic stacking technology deployed in the event of stacked devices. Power supplies, inter-stack"
"cabling, SFP (small form-factor pluggable) module insertion, and the assembly of all devices take place either within the warehouse or during the on-site truck roll. At the end of day–1, devices are typically flashed with the selected software image, basic testing has been performed, and minimal configuration has been applied. Devices are then repackaged with their unique identifiers (hostname, management IP address) and delivered to the data center, rack, or telecom closet for"
"ptg45047941

From the Library of Tos Chaiwong

Traditional Network Operations 5

installation and day 0 configuration. The sections that follow look at some tasks that can be automated in day–1.

Offline Initial Configuration"
"Using a testbed file, covered in detail in Chapter 3, “Testbeds,” new devices can be described in human-readable YAML format at scale. By extending the YAML file to include the intended state, the initial configuration can be derived from APIs or Jinja2 templates in an “offline” approach. The result is a simple, but validated, initial configura- tion file derived from the low-level design that operators can quickly and accurately apply via a serial connection in the warehouse. This is not only faster, which is a goal of the typically highly manual process of day–1 configuration, but it is more accurate, of higher quality, and it dramatically simplifies the process for human operators. Instead of having to manually adjust a set of default instructions per device or translate an IP address plan into management IP address configurations, pyATS can be leveraged to automate this process and provide human operators with ready-to-go initial configurations that are easily applied over the serial connection."
"Software Images

All network devices and appliances should have either the latest or the vendor-recommended release applied to them during the day–1 process. Images can be distributed locally using USB drives or downloaded from a centralized image repository that is reachable after the initial minimal configuration is applied.

pyATS can play an important part of day–1 activity and automate both the initial base configurations as well as the software image management. The pyATS Clean framework, further explored in Chapter 15, “pyATS Clean,” can be used to load new images and apply a base configuration."
"Day 0

Day 0 is the onboarding process. Devices are racked, stacked, powered on, and intercon- nected in their location in the network depending on the role they will play. It is at this point where connectivity to the devices’ neighbors, centralized management, orchestra- tion, and monitoring systems are established. Access from distributed operator worksta- tions or the management zone is also established, providing access to pyATS to perform additional configuration. The remaining configuration items that rely on the device being connected to the full network topology can now be pushed from pyATS. There are many advantages to using pyATS to complete the day 0 onboarding configurations, including the following:

■ Intent-driven configuration from the testbed YAML file for a single device or an

entire new topology at scale

■ Templated configurations from APIs or Jinja2

■ Pre-change state capture

ptg45047941

From the Library of Tos Chaiwong

6 Chapter 1: Foundations of NetDevOps"
"■ Automated configuration deployment

■ Set of initial pyATS tests validating the onboarding

■ Post-change state capture

■ Differential output comparing day–1 and day 0 configuration states

■ Automated state capture

■ Automated business-ready documentation

With pyATS, network engineers can move towards “zero-touch provisioning” (ZTP) without using Plug and Play (PnP), DHCP, and TFTP/FTP/SCP server infrastructure to achieve automated onboarding of any size or scale. The sections that follow look at day 0 activities than can be automated with pyATS.

Layer 1"
"Layer 1 wiring and cabling of infrastructure is still required, unfortunately, and device interconnectivity (which ports connect to which ports) still needs to be mapped out from the low-level design. One major advantage of pyATS is that these interconnects can be quickly and automatically tested as part of the onboarding job. The presence of certain neighbor relationships, like Cisco Discovery Protocol (CDP) or its open standard coun- terpart Local Link Discovery Protocol (LLDP), or even OSPF or BGP neighbors, can be added as tests in the provisioning job. Engineers can review the job logs to quickly and easily determine if the provisioning was successful based on the results of these tests. Ping tests can be used to validate reachability from a given device to another destination in the network, and interface tests can be used to confirm the lack of errors or the pres- ence of full-duplex connectivity, at scale, across entire testbeds. Network engineers can be reassured by pyATS that devices have been"
deployed correctly and that the required wiring is in place at the end of the onboarding process.
Initial Configuration
"Initial configuration can be derived from the combination of the pyATS testbed and either pyATS application programming interfaces (APIs) or Jinja2 templates (expanded upon in Chapter 7, “Automated Network Documentation”) that provide the Cisco IOS configuration code required to complete the devices’ onboarding process. Much like the initial day–1 configuration, each device can use an intended configuration abstracted from Cisco OS configuration stanzas into human-readable structured data files. Every aspect of a device’s configuration can be transformed in the simple testbed file and then the actual configuration called from either pyATS APIs or Jinja2 templated configura- tions. Using a NetDevOps approach and Git version and source control, the entire life- cycle of a device’s configuration can be tracked from day–1 initial configuration and onboarding configuration all the way through to day N configuration. In fact, using this approach with pyATS, day–1 and day 0 initial configurations could be merged"
"into a single intent-based, templated configuration, reducing the deployment lifecycle to a single stage of development. If you either apply initial minimal configurations and then"
"ptg45047941

From the Library of Tos Chaiwong

Traditional Network Operations 7

complete the full configuration over two phases or merge the initial configurations to be totaled and completed in day–1, there is a major reduction of error-prone, human-driven, initial configuration management with pyATS."
"Initial Testing and Validation

In the preceding “Layer 1” section, we discussed how pyATS opens up a myriad of testing possibilities after the initial onboarding phase. This encompasses reachability, neighbor relationships, interface configuration, and counter-information assessments—all crucial for ensuring a smooth onboarding process. However, as will be unraveled in the subsequent chapters of this book, pyATS’s utility goes beyond just these preliminary tests. Any output from a show command can be rigorously scrutinized through pyATS tests. Once the initial onboarding configuration is deployed to the device by pyATS, you have the freedom to design tests tailored to your specific needs, aiding in validating the success of the onboarding processes."
"Before the onsite technicians conclude their tasks at the deployment site, pyATS tests serve as a reliable tool to ascertain that no manual interventions or amendments are neces- sitated. Devices can be drop-shipped with preconfigurations and, upon arrival, be auto- matically tested to ensure they are in a healthy state, connected accurately, and configured in alignment with the intended design. This eradicates the traditional dependence on the command-line interface (CLI), sifting through the output of various show commands, and relying on human operators to undertake the challenging task of validating a device’s con- figuration and state. Instead, pyATS automates these tasks, with its job logs and HTML log viewer significantly simplifying the most arduous aspect of day 0 configuration—ensuring accurate configuration and connectivity during the onboarding phase."
"The narrative so far has revolved around the correctness of an individual device being onboarded and its interaction with neighboring devices. However, there’s a broader per- spective to be explored. pyATS is not confined to device-centric validation; it extends to scrutinizing the state of the entire network system. For instance, even if the configura- tions are accurate, interfaces are active, and routing adjacencies are established, there might be underlying routing faults or perhaps a newly defined prefix or ACL malfunc- tioning. These issues might manifest at an area border router or a peering router situated elsewhere in the network. pyATS empowers us to delve deeper and test for such network- wide anomalies too! It’s not just about the correctness of individual device configurations but a holistic examination of the network system’s state, ensuring everything operates cohesively and as intended across the network infrastructure."
"Day 1

Day 1 can be demarcated by everything that occurs after network devices are onboarded, provided their initial configuration(s), tested, and validated as ready for service. Day 1 can be further broken down into day 2 and day N configurations for simplicity and provided further demarcation of tasks. pyATS plays a critical role in day 1, allowing network engineers and operators to update their intent files to reflect required changes to the network configurations. Intent should be the only place network staff members

ptg45047941

From the Library of Tos Chaiwong"
"8 Chapter 1: Foundations of NetDevOps

need to update, but in cases of provisioning new services, new APIs or Jinja2 templates will also need to be developed to support services that were not in scope of the original intended configurations. Using Git and a Git repository, these changes should also be part of a working branch, tested and validated, and ultimately merged back into the main branch and deployed to the network devices as part of a CI/CD pipeline, as covered in detail in Chapter 21, “CI/CD with pyATS.” Human error is virtually eliminated in this CI/CD process, as only the easy-to-read, human-compatible YAML file is changed and pyATS takes care of the rest of the configuration management. The sections that follow cover some day 1 activities that can be automated with pyATS.

Incremental Configuration"
"As the network evolves over time and things change, the configuration of the network also evolves and changes. This could be something as simple as a new Network Time Protocol (NTP) source or Dynamic Host Control Protocol (DHCP) server that needs to be config- ured to make the network devices aware of it. Prior to network automation, operators would need to connect to each device in the network, possibly dozens or hundreds of devices, and manually apply the changes using the CLI. This was time-consuming, error- prone, and obviously not the best use of a person’s time. Configuration drift between the intended configuration and state and the actual running configuration also occurs over time. Until every device is reconfigured, there is disparity between devices. Changes might take hours, days, weeks, or even months to complete, depending on the size of the network and available resources. These changes are also prone to human error, where the wrong device, incorrect information, or simple missed keystrokes"
"could lead to disparity between the intent and the actual configurations. In a worst-case scenario, outages or interruptions to the flow of network traffic are introduced accidentally as a result of these human errors."
"The reconfiguration is also only part of the story; testing and validating the changes are also required, compounding the time it takes to establish confidence the change was successful. Often, the validation can take longer than the actual change itself.

pyATS really shines in day 1 activities, as it not only can derive a configuration directly from the intended state but can also configure, test, and document these changes at scale, automatically, without a human ever having to log in to the CLI:

■ Capture the pre-change configuration

■ Test the pre-change state

■ Report errors and abort the change

■ Confirm an error-free state

■ Push configuration to the device

■ Test the post-change state

■ Report errors and roll back the change

■ Confirm an error-free state

■ Confirm the intent delivered

ptg45047941

From the Library of Tos Chaiwong

Traditional Network Operations 9

■ Capture the post-change state

■ Update the documentation

■ Perform a differential"
"■ Display changes to the configuration and state

Provisioning New Endpoints

Networks grow in size as capacity is required. Fortunately, with pyATS, all we need to do is add new devices’ intended configuration to the testbed file. The initial configuration will be generated for offline installation, and the initial image and configuration will be automated. The new devices can be tested and existing device tests modified to accom- modate the presence of a new device. So not only can new devices be quickly and accu- rately added to existing networks and tested as new devices, the existing network can be regression-tested to validate no unintended consequences or impacts occurred as the result of the presence of a new device."
"Provisioning New Services

The only time anything is developed outside the testbed file is when new services are provisioned. The data model, the YAML intent in the pyATS testbed file, and the accom- panying pyATS APIs or Jinja2 templates all will need to be created to provide these new services. If, for example, quality of service (QoS) was not deployed as part of the day 0 onboarding but needs to be configured to achieve the business SLAs, to support new devices such as voice over IP (VoIP) devices or IP cameras, or to reduce congestion in the new network topology, the QoS model needs to be mapped to the intent data model in YAML and then the appropriate APIs or Jinja2 templates developed. The pyATS tests to support the validation of the implementation also need to be developed. pyATS can reduce the time it takes to develop and deploy new services as networks become “agile,” not “fragile.”"
"Day N

Day N activities involve the day-to-day activities performed to maintain a healthy net- work state. In the past, network operations typically involved monitoring the network for system logging (syslog) events pushed from the network in response to activity on a device and Simple Network Monitoring Protocol (SNMP) polling (pulled from the device at intervals) or traps (events pushed from the device) and then responding according to these events. The sections that follow describe Day N network managing and monitoring activities in more detail.

Monitoring (and Now Testing)

Traditional network monitoring can be greatly augmented with pyATS testing. In addi- tion to syslog and SNMP events, the network can now be proactively tested by pyATS to confirm that the intended configuration and state are maintained. pyATS also adds

ptg45047941

From the Library of Tos Chaiwong

10 Chapter 1: Foundations of NetDevOps"
"context to sometimes vague syslog or SNMP information. A typical alarm from syslog might indicate an interface has gone down, leaving operators to determine the impact of losing that interface. This analysis might take time, and low-level designs might need to be referenced to determine the impact of a particular interface indicating it is down. With pyATS, it can be quickly and easily determined that an interface has gone down as well as what other impacts that failed interface has had on a device or even the entire topology. Multiple pyATS instances might start to fail (such as neighbor relationships and establish- ments), routing protocol or routing table tests might start to fail, and ping and other con- nectivity tests might also start to fail. The scope of the impact can easily be determined using ongoing scheduled pyATS tests and the severity of the outage can be established rapidly without ever having to log in to a device or multiple devices to assess the impact. This is just one example of an"
"interface going down, but every facet of a device or entire network’s configuration, state, and health can be continuously tested by pyATS arming network operations with automated capabilities far beyond syslog and SNMP."
"Responding to Events

In addition to traditional monitoring and the new continuous testing capabilities offered by pyATS, day N management of networks includes network operations responding to events encountered by network-generated syslog or SNMP traps or failed pyATS tests. One of the major benefits of pyATS is that it provides built-in alerting capabilities, including sending test reports by email or even via a messaging platform such as Webex, Slack, or Discord. Individual failed tests can also be sent as Webex alerts to the operators or engineers responsible for responding to and remediating failed tests. pyATS allows for proactive response to events, as failed tests can identify user-impacting failures imme- diately and alert those responsible for addressing the situation. This is a paradigm shift from either trying to make sense of multiple syslog or SNMP traps or, worse, responding to calls from the users impacted by the degraded network state.

Upgrading"
"Software image management is also a major part of day N operations and network man- agement. Network vendors such as Cisco release frequent updates to address flaws in existing software releases or to release new features and components to the software image. Security patches are also a major consideration and should be addressed accord- ing to the severity of the security flaw. With the combination of pyATS testing and pyATS Clean framework, software image management becomes dramatically easier as operations are able to regression-test new images against a known working state. pyATS tests can be used to validate the software upgrade has not modified the configuration or state of the network compared to the previously working baselined tests. The pyATS Clean framework can be used to deploy software and related configurations, ensuring successful software upgrades. Should commands need to be modified as the result of a new software image, the pyATS testbed (human-readable intent), pyATS APIs, or Jinja2"
"templates can be modified and new configurations generated and deployed to respond to changes in the structure of device configurations, deprecated configurations, or net-new configuration requirements—all automatically, quickly (with agility), and with the highest"
"ptg45047941

From the Library of Tos Chaiwong

Software Development Methodologies 11

quality. Once again, pyATS can be used to test individual devices in isolation as well as the entire topology before and after software images are upgraded.

Decommissioning

At the end of a device’s lifecycle, it will need to be decommissioned and likely replaced with a newer model. The process starts over again from day–1 and the replacement device is onboarded. One major advantage of using pyATS is that the original device’s intent and configuration APIs or templates can be used to provide a baseline and then reused to develop the replacement device’s configuration. The data model and templates may need to be adjusted, but the operator is not starting from scratch. Both the configuration and test suite can be reused to provide rapid device replacement and decommissioning and reprovisioning of new devices."
"Software Development Methodologies

The development practices, processes, and culture are as important, if not more impor- tant, than the code and network configurations and are often the most difficult changes to adapt. Traditional networking has mostly followed the waterfall methodology—legacy processes from almost 50 years ago! Software developers have adopted a more modern approach, known as Agile, which emerged in the early 2000s. This is a big reason the world around us is dominated by ever-evolving applications and innovation. Can we bring these Agile practices to the world of networking? Yes, it is known as NetDevOps. It is important to understand the evolution from waterfall practices to Agile practices and DevOps to see how well this new approach works with modern network engineering. The sections that follow contrast the various software methodologies."
"Waterfall

Most networks have historically been managed using the waterfall methodology. In fact, if you review the traditional network section, the various stages of the waterfall process can be mapped to the architecture, high- and low-level designs, and day–1 to day N activities. Waterfall revolves around a linear progression from one phase to the next with an emphasis on gathering and defining requirements at the beginning of the project and building solutions in rigid phases of the project’s lifecycle. Each phase builds upon the previous phase’s deliverables as work flows down the waterfall:

1. Requirements are captured in a network requirements document.

2. High-level details lead into lower-level details. These details come from requirements that are analyzed to produce IP schemes, subnets and VLANs, routing, ACLs, and other network models, and schemas are produced.

3. A network architecture and high-level designs are created."
"4. Network configurations are developed from the architecture and designs.

5. Devices are onboarded and configured.

ptg45047941

From the Library of Tos Chaiwong

12 Chapter 1: Foundations of NetDevOps

6. Testing occurs and networks are debugged and validated.

7. Operations take over, and the resulting network is monitored.

According to the waterfall methodology, a new phase can only begin when the preceding phase has been reviewed and tested, leading to a potentially long and rigid overall project. The waterfall approach was widely used in the 1970s and 1980s, particularly in software development and project management."
"Lean

In the 1980s, the Japanese automotive company Toyota developed a system known as “The Toyota Way,” or the Toyota Production System (TPS), in an effort to improve efficiency by reducing waste. This system was coined “Lean” in 1988 in the John Krafcik article “Triumph of the Lean Production System” and defined in 1996 by American researchers James Womack and Daniel Jones. Lean production primarily focused on reducing production times and delivering “just-in-time” (JIT) manufacturing, matching production to demand. A major byproduct of Lean was the elimination of waste from the production processes and the use of automated quality controls. The five key principles of Lean, as outlined by Womack and Jones, are as follows:

■ Precisely specify value by product.

■ Identify value stream for each product.

■ Make value flow without interruptions.

■ Let customers pull value from the producer.

■ Pursue perfection.

Ultimately, Lean was defined as a way to do more with less and maximize efficiency."
"Agile

Stemming from the Lean changes in the manufacturing sector and management approaches in the early 1990s and seeking to define a new approach to software development and operations, 17 software developers met in 2001 to discuss lightweight development practices and released the “Manifesto for Agile Software Development,” which defined what they valued as software developers. This new approach strived to bring in some of the Lean manufacturing principles, such as reducing times in the production process, JIT manufacturing, and the overall elimination of waste from the pro- cesses, and apply them to software development. This was in sharp contrast with previous heavyweight development approaches such as the predominate waterfall methodology. Agile is based on the following 12 principles:

1. Provide customer satisfaction by early and continuous delivery of valuable software.

2. Welcome changing requirements, even in late development.

ptg45047941

From the Library of Tos Chaiwong"
"Software Development Methodologies 13

3. Deliver working software frequently (weeks rather than months).

4. Close, daily cooperation between business people and developers.

5. Projects are built around motivated individuals, who should be trusted.

6. Face-to-face conversation is the best form of communication (co-location).

7. Working software is the primary measure of progress.

8. Sustainable development, able to maintain a constant pace. Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.

9. Continuous attention to technical excellence and good design enhance agility.

10. Simplicity—the art of maximizing the amount of work not done—is essential.

11. Best architectures, requirements, and designs emerge from self-organizing teams.

12. Regularly, the team should reflect on how to become more effective and then adjust

accordingly."
"DevOps

DevOps is a set of practices, processes, and tools that bring the world of software development (Dev) and IT operations (Ops) together as one cohesive discipline. Much like Lean, the goals of DevOps are to shorten the systems development lifecycle (SDLC) while providing continuous improvement and high software quality. Many ideas in DevOps come directly from the Agile methodology. The key principle of DevOps is breaking down barriers and silos of developers and operations, bringing a shared sense of owner- ship over the product. Automation is a core component of DevOps, and the tools used to implement DevOps are critical to its success. Automated build and testing, continuous integration, continuous delivery, and continuous deployment, which originated in Agile, are pillars of DevOps."
"Expanding into Networks

Seeing the obvious benefits of Agile and DevOps, the world of networking has adopted the practices, processes, and many of the tools into NetDevOps, especially after the availability of many new network automation tools, including pyATS. Hank Preston, prin- cipal engineer at Cisco, defines NetDevOps as follows: “NetDevOps brings the culture, technical methods, strategies, and best practices of DevOps to networking.” The first point Preston makes is that the culture of DevOps, as well as the technical aspects, needs to be adopted by the networking team first to embrace NetDevOps. Networks need to become “agile,” and not “fragile,” and the impacts on the network due to the blast radius still need to be respected.

ptg45047941

From the Library of Tos Chaiwong

14 Chapter 1: Foundations of NetDevOps"
"Infrastructure as Code

One of the first breakthroughs for NetDevOps was the widespread adoption of what has become known as infrastructure as code (IaC). Elements of infrastructure, like the network, are defined in structured data like YAML Ain’t Markup Language (YAML) and JavaScript Object Notation (JSON) as well as configurations delivered with Python, RESTful APIs, or traditional CLI commands abstracted as code elements. Treating infra- structure as code enables NetDevOps and the application of software development prac- tices like Agile to traditional waterfall network lifecycles. pyATS is an implementation of IaC allowing NetDevOps to use Python to program solutions for the network."
"Test-Driven Development

By using a Python library and treating the infrastructure as code, not only can NetDevOps be applied and Agile principles enacted, but other software development practices can be utilized to maximize IaC quality, including an approach known as test- driven development (TDD). Testing is built into the process as requirements are broken down into small units known as test cases. Instead of building a full product and then testing it, testing occurs during the development cycle, where each unit is tested, and finally all tests are executed against the whole product. This approach fits very well with NetDevOps, and pyATS in particular, as network requirements can be broken down into consumable-sized test cases, developed and configured, and then tested for quality. TDD encourages simple designs and, according to Kent Beck, who is credited with developing the technique, “inspires confidence” in developers."
"NetDevOps

NetDevOps, a philosophy blending the methodologies, cultural practices, tools, and Agile approach from DevOps with network operations, facilitates a seamless transi- tion from day–1 to day N network activities within the DevOps model. Central to NetDevOps is the ethos of continuous improvement, characterized by delivering high- quality code through frequent releases and iterations, enhancing network performance and reliability. Figure 1-1 delineates the DevOps lifecycle, which is elucidated in greater detail in the subsequent sections.

Cisco pyATS, a pivotal tool in the NetDevOps arsenal, seamlessly integrates within this lifecycle, acting as a catalyst in automating and validating network states and configura- tions. Here’s how Cisco pyATS interlaces with the NetDevOps process:

1. Planning and coding: In the initial phases of the DevOps cycle, network designs"
"and configurations are conceived and coded. Cisco pyATS can be leveraged to script automated tests, ensuring the integrity and efficiency of network configurations right from the drawing board.

2. Testing: After the coding phase, Cisco pyATS shines in the testing domain. It auto-

mates the validation of network configurations, reachability, and the state of various network elements. This automation expedites the testing process, ensuring that any deviations from the intended configurations are promptly identified and rectified.

ptg45047941

From the Library of Tos Chaiwong"
"NetDevOps 15

3. Integration and deployment: As new code and configurations are integrated and deployed, Cisco pyATS continues to play a crucial role. It aids in automating the deployment process while concurrently running validation tests to ensure seamless integration with existing network setups.

4. Operation: During the operation phase, Cisco pyATS facilitates continuous moni-

toring and validation of the network, ensuring it aligns with the defined operational standards and configurations. This continuous validation is instrumental in maintain- ing network reliability and performance.

5. Monitoring and feedback: Cisco pyATS provides a robust framework for monitoring network states and collecting valuable feedback. This feedback is crucial for identify- ing areas of improvement, which feeds into the planning phase for subsequent itera- tions, thus completing the cycle.

6. Continuous improvement: By providing insightful data and automation, Cisco"
"pyATS fosters a culture of continuous improvement within the NetDevOps frame- work. It facilitates quicker iterations and releases, ensuring that the network is always optimized and aligned with evolving organizational needs.

Incorporating Cisco pyATS within the NetDevOps framework elevates the efficiency, reliability, and agility of network operations, embodying the continuous improvement spirit central to the NetDevOps philosophy. Through automation and validation, Cisco pyATS propels networks closer to the aspiration of self-operating and self-healing infra- structures, making it an invaluable asset in modern NetDevOps practices.

chinnappa / 123RF

Figure 1-1 DevOps Lifecycle

ptg45047941

From the Library of Tos Chaiwong

16 Chapter 1: Foundations of NetDevOps

Plan

Fail to plan, plan to fail. For “greenfield” or “net-new” networks, we begin with planning. Business requirements, service level agreements, architectures, and high- and low-level designs drive the planning phase of NetDevOps."
"Code

Instead of manually crafting configurations in NetDevOps, we start to create data models, templates, and code to generate and deliver configurations to the devices. pyATS testbeds, covered in depth in Chapter 3, describe devices and topologies that are modeled in YAML as intent. Jinja2 templates or pyATS APIs are also used to create the Cisco OS configuration code, substituting values from the YAML intent in the form of variables. Using pyATS, developers can approach the coding phase using test-driven development (TDD), creating tests that initially fail, and then are coded to pass, to vali- date intent and connectivity."
"Build

Code is packaged up in builds as part of the continuous integration (CI) portion of CI/CD. Build often implies the creation of a delivery vehicle for the code—in the case of pyATS, this could be a pyATS job. pyATS jobs can also be further packaged up into Docker container images as part of the build process. Builds are automated using tools in the CI/CD process. In DevOps, builds are typically packaged software, but in NetDevOps builds represent intended configurations; templated configurations; connec- tivity, configuration, and integration tests; automated documentation; and other network- centric code in the form of pyATS jobs."
"Test

As part of the CI/CD process, after we have a functional build and individual pieces of code tests using TDD, a larger testing process occurs in NetDevOps. Our build is tested, our full set of tests are executed, and larger, complete end-to-end tests are performed. The goal is to identify bugs or flaws in the code as early as possible. Linting, or program- matically checking code for syntax or stylistic errors, is also performed as part of the test phase to improve the quality of the code. Passed tests are also part of the version and source controls acting as a gate in the approval process used to merge code into the code base. Human approvals and quality assurance are also performed in the test phase prior to releasing code.

Release

Testing for infrastructure as code often includes the continuous delivery step of CI/CD, where the build is released to a virtual or physical non-production environment. This could be a mocked-up smaller-scale representation of the production network in a

ptg45047941"
"From the Library of Tos Chaiwong

NetDevOps 17

network simulation platform such as Cisco Modeling Labs (CML), or it could be a physical lab or pre-production environment. The build is delivered to this environment where more comprehensive integration testing can occur. Everything from connectivity to configuration and network state can be tested and bugs can be identified. In the event of failed tests at this phase, the process returns back to the planning, coding, building phases of NetDevOps, allowing for high-quality, nondisruptive, perfected builds before moving to the release, or continuous deployment, phase of the process. After passing all tests in the pre-production environments, the candidate release is moved into the deploy- ment phase.

Deploy"
"DevOps deployments are software in nature, deploying the latest version of code to systems and users. In NetDevOps deployments, the continuous deployment portion of CI/CD pushes configuration changes to the production network. This might not be imme- diate, as in the case of software, because the impact on networks compared to the impact on software is much greater. Change management approvals and release scheduling are included in network deployments, and the actual release will need to be automatically triggered during the approved change windows. Automated deployments run the pyATS job within the Docker container, resulting in changes being pushed to the network devic- es. pyATS tests from the previous step are executed against the production environment to confirm and validate the change was successful and the intended configurations were integrated without impact or network degradation. Using IaC and the CI/CD pipeline, if the pyATS tests fail, a rollback could be triggered and the network returned to"
its previously known-good configuration state.
Operate
"The Ops portion of NetDevOps takes over, and standard network operations continue to support the network, including the newly released configurations and features. The reduction of silos and the collaboration between developers and operators provide immediate and continuous feedback, validating that the network performance or recently released features and configurations are working as intended. There is no hand-off here as under the waterfall methodology; in fact, the operations team has been integrated with the development portions of this continuous cycle. Developers are also able to provide direct support and handle escalations from operations, thus ingraining themselves in the operations of the network. In a “brownfield” (existing) network, the NetDevOps cycle may actually start at the operations phase where developers and operators collaborate to tackle the automation of an existing network. Systems previously deployed manually under waterfall are analyzed by developers and operators and the"
"configurations and state of the network are transformed into pyATS-driven, automated, tested, intent-based networks. The real-world experience from operations is used to provide developers the ability to start the planning phase of NetDevOps, and the cycle starts."
"ptg45047941

From the Library of Tos Chaiwong

18 Chapter 1: Foundations of NetDevOps

Monitor

Traditional network management systems (NMSs), syslog events, SNMP events, and, now, pyATS testing results are all used to monitor the health and performance of the network. The impact of the release is monitored as well as the overall state of the network, and metrics are used to provide feedback to the NetDevOps team to start the planning phase for the next release, either to remediate flaws from the previous release or to add addi- tional enhancements, configurations, tests, or capacity. This process is followed in an endless cycle of continuous improvement following a version and source-controlled CI/CD pipeline driven by pyATS."
"Additional Benefits of NetDevOps

The NetDevOps lifecycle itself will bring many benefits and advancements in your journey towards test-driven automation. Some of these benefits will be technologically based and others cultural. The primary benefit is the elimination of the silos between developers and operators, thus fostering an open and collaborative culture. Let’s explore some ancillary benefits to NetDevOps.

Single Source of Truth"
"One of the major benefits, in addition to the Agile methodology, automated CI/CD pipeline, and test-driven development, of NetDevOps is the creation of a source of truth. Legacy networks are plagued by the lack of a central authoritative source of truth—what is the intended configuration and state of the network? Is it the collection of running configurations on each device in the network? Is it offline in a spreadsheet? Is it in an engineer or operator’s head? NetDevOps creates version- and source-controlled intent files, templated configurations, tests and test results, and the mechanism (the CI/CD pipeline) to develop and release changes automatically. Configurations can also be stored and managed in a network source-of-truth platform, such as Netbox or Nautobot. Occasionally, under degraded circumstances, human operators may need to manually intervene and make changes directly at the CLI of some devices to restore critical net- work connectivity, which can lead to configuration drift and come into"
"conflict with the source of truth. Immediately after manual remediation of the network, these changes need to be reflected in the code base, new intent and templates generated, and new or existing tests created and modified. Adoption of NetDevOps will reduce these “priority- one” events over time, and less and less human intervention will be required."
"Intent-Based Configuration

A major component of the single source of truth is the intent: what the network engineers, developers, and operators agree should be the configuration and state of the network to fulfill the business requirements and establish a healthy, secure, redundant, resilient, high-performance network. Using pyATS, intent can be reflected in easy, human- readable YAML files, which are not concerned with a device’s OS-specific configuration

ptg45047941

From the Library of Tos Chaiwong"
"NetDevOps 19

and abstract away the complexity of the working configuration. These intent files can be sourced from either templates or API calls to a source of truth that handles the genera- tion of working device OS configuration code. The “compiled” composite output pro- vided by pyATS is a working, valid, OS-specific configuration. pyATS testing can then be used to validate and confirm that the actual configuration matches the intended configu- ration. Configuration drift is eliminated, as is human intervention at the command line. What should be the configuration of a device is always known and can be referenced offline using a single source of truth. Version and source control are applied to the single source of truth, intended configuration files, and templates used to generate the code.

Version and Source Control"
"As an infrastructure as code approach is adopted, version and source control become vital to a successful NetDevOps culture. Working code, the known-good intent, templates, and tests are protected in a Git repository, and Git is used to provide the mechanism to safely develop iterations of the code base. Git also empowers NetDevOps collaboration, allowing individual members of the team to develop their own code inside branches as part of the NetDevOps code stage of the cycle. Code is tested and validated and then merged into the main repository. The entire lifecycle of a device’s intent, test and test results, documentation, and configuration is preserved, and versions of the network are available from the initial onboarding to day N and end-of-life. Rolling back to a previous version of a known-good state can be done via the release process. Sometimes known as GitOps, this process drives the CI/CD pipeline. pyATS jobs, tests, intent, and templates are all protected by the version and source control process,"
"and only validated code is ever used in the build, release, and deploy stages of NetDevOps."
"GitOps

NetDevOps relies heavily on Git and Git repository systems. GitOps is the process of triggering the CI/CD pipelines when Git branches are merged into the main branch. NetDevOps developers make a working branch from the main branch in order to code a new feature or address deficiencies in code iterations, test their code, and submit a pull request, requesting their branch be merged into the main branch (with the single source of truth containing only validated, working intent). Once approved and completed, the pull request kicks off the CI/CD pipeline, and tests, builds, releases, and deployments occur automatically. Git is much more than just version and source control; it is a key component of the CI/CD process and NetDevOps."
"Efficiency

NetDevOps eliminates wasted effort, and efficiency is achieved using automation. Humans reclaim the time previously spent drafting and configuring changes, device by device, manually. Everything from tests to documentation to configuration management is driven by automation, and people are empowered to spend their time on more valuable problem-solving. Quality is built into the process, and only validated changes are released to the production network reinforced by automated testing at every stage of the lifecycle.

ptg45047941

From the Library of Tos Chaiwong

20 Chapter 1: Foundations of NetDevOps

In a well-defined NetDevOps process, only the intent, templates, and tests ever need updating by human beings, who rely on automation tools, version and source control, and the CI/CD pipeline to perform previously manual processes. Networks can be treated as cattle, and not pets, and “snowflakes” are eliminated as the single source of truth, ensur- ing uniformity across the network."
"Speed

Automation, often synonymous with enhanced speed and performance, brings about a paradigm shift in network operations. Its prowess in exponentially outperforming manual processes, especially at larger network scales, is unequivocal. While a human operator is still launching their terminal client, logging in, authenticating, and navigating the CLI, most automation tools have already accomplished their tasks. The velocity of automation transcends just the configuration changes or network state captures; it significantly expe- dites the testing phases preceding and following these changes. Network operators sel- dom find the task of adding a few lines of configuration to a network device or multiple connected devices time-consuming; rather, the bulk of their time is invested in validating the impact of these changes. They need to ensure the desired outcomes are achieved without introducing any unintended repercussions that might degrade the network ser- vice."
"Incorporating the NetDevOps approach alongside tools like pyATS can dramatically shrink the change windows from days or hours to mere minutes or seconds. This trans- formation propels networks from being fragile and static, where changes are a harbinger of potential problems, to becoming agile entities. In these agile networks, frequent altera- tions can be executed not only swiftly but with a high degree of quality.

Yet, the velocity afforded by automation carries a double-edged sword. It undeniably speeds up network operations, but concurrently, it has the potential to propagate errors or induce network issues at an equally accelerated pace. As the adage goes, “With great power comes great responsibility!” The discussion hitherto has skirted around a critical aspect—risk. The rapidity of automation can swiftly escalate into a network debacle if not wielded judiciously."
"A robust risk mitigation strategy is indispensable to harness the full potential of automa- tion while averting the pitfalls. Employing comprehensive unit and system tests, both pre- and post-implementation, is a prudent practice. These tests serve as a safeguard, ensuring that the automation scripts are functioning as intended and the network remains resilient after the changes. By meticulously managing the risks through rigorous testing, automation transitions from being a potential liability to a formidable asset in network operations. This balanced approach empowers network operators to exploit the efficien- cies of automation via NetDevOps and pyATS, while keeping the associated risks at bay. Through a disciplined execution of testing protocols, automation in network operations transcends from being merely a tool for speed, to a well-oiled machinery driving speed, quality, and reliability in an ever-evolving network landscape.

ptg45047941

From the Library of Tos Chaiwong"
"Comparing Network Automation Tools 21

Agility"
"The statement “the network has long been the bottleneck in responding to ever-increasing demands from the business” encapsulates the challenges faced by traditional network infrastructures in keeping pace with the rapid evolution of business needs. As businesses burgeon and diversify, the demand for more robust, scalable, and agile network systems escalates. However, legacy networks, often encumbered by manual configurations, scal- ability limitations, and slower adaptation to new technologies, struggle to meet these bur- geoning demands swiftly. This lag in network adaptability hampers operational efficiency and the timely execution of business strategies, thus acting as a bottleneck in fulfilling the ever-increasing business requisites. Applications, servers (compute and storage), and security, having adopted DevOps, are rapidly made available while the organization waits for network services to enable these new capabilities. NetDevOps allows the network to respond rapidly to business demands by working"
"with network infrastructure as code. Again, networks can become agile not fragile. NetDevOps simply needs to update their intent, develop new templates and validation tests, and perform the build/deploy/release stages iteratively. The business no longer waits possibly days or weeks for the network teams to respond manually in a waterfall process. Distributed, collaborative teams can rapidly develop and release the changes required to respond to business demands using the NetDevOps approach."
"Quality

Above speed and agility, the number-one driver for NetDevOps is the quality of solu- tions. According to a recent Uptime Institute survey, “How to avoid outages: Try harder!,” 70–75% of data center failures are caused by human error, producing a chain effect of downtime. Additionally, more than 30% of IT services and data center operators experi- ence downtime or severe degradation of service. Also, 10% of the survey respondents reported that their most recent incident cost them more than $1 million. Elimination of human errors using NetDevOps methodology and automation tools like pyATS is the number-one driving factor for the adoption of IaC solutions. While moving faster and with more agility is definitely beneficial to the business, the reduction of human errors, and thus network outages, is paramount to a successful NetDevOps implementation."
"Comparing Network Automation Tools

Along with culture and software development lifecycle methodology changes, NetDevOps brings new tools to the network engineer’s toolkit. For 40 years, most engi- neers have had a few simple tools, including a terminal client and a text editor, to perform their day-to-day tasks to configure, validate, document, and test their networks. Over the past 5 years, the number of new tools has exploded, dramatically simplifying, and at the same time complicating, the role of a network engineer:

■ Agent-based tools: Agent-based tools require software to be installed onto the net- work device, acting as an agent for remote commands. Tools like Puppet, Chef, and Salt Stack are examples of popular network automation tools that require an agent.

ptg45047941

From the Library of Tos Chaiwong"
"22 Chapter 1: Foundations of NetDevOps

A centralized controller communicates using an agent protocol to the agents deployed into the network devices. Agent-based tools have lower bandwidth requirements, are perceived as more secure, and have a central point of management with the trade-off of performance, cost, and deployments times."
"■ Agentless tools: In contrast with agent-based tools, agentless tools use protocols like SSH and HTTPS from distributed systems to perform their automation tasks. Nothing needs to be installed on the network devices to enable agentless automation tools. There is no centralized controller, and typically costs and complexity are dras- tically reduced. Ansible has become an extremely popular network automation tool, partly because it is agentless. Performance, costs, and deployment time are all bene- fits of agentless network automation tools. pyATS is an agentless tool requiring only SSH, Telnet, or HTTP/HTTPS access to a network device. pyATS testing can even be performed against offline JSON files without any connection to the device at all."
"The Modern Network Engineer Toolkit

In addition to network automation tools, agent or agentless, the modern network engi- neer’s toolkit includes many additional tools and technologies to perform NetDevOps tasks. Gone are the days of having a simple terminal client and text editor; network engi- neers must embrace the growing landscape of tools in order to approach problem-solving as a software developer that simplifies their roles and increases quality, time to delivery, and agility. The sections that follow look at the various tools and technologies that should be part of every modern network engineer’s toolkit.

Integrated Development Environment

Infrastructure as code implicitly requires NetDevOps to write code. While a simple text editor could be used, an integrated development environment (IDE) will help network engineers write quality code with a superior experience. In this book, we will be using Visual Studio Code (VS Code) as the IDE of choice; however, many alternatives are available."
"“Old School”

Historically, simple text editors like Notepad were used to draft configuration changes and to consume network state from the command line offline. The historical text editor is quite limited in its capabilities and functionality. With the advent of new structured data types such as JSON and YAML, as well as the need to write code in software languages like Python and JavaScript, using a plain text editor leads to poor quality code with syn- tax and indentation errors (particularly in YAML and Python) that will not compile or execute properly. Users are forced to manually detect these flaws, often using time- consuming trial and error approaches. Classic text editors are also not aware of version

ptg45047941

From the Library of Tos Chaiwong"
"The Modern Network Engineer Toolkit 23

and source control, and cannot preview rendered output such as Markdown or Comma- Separated Values (CSV) files, which require another tool to view in their rendered state. Working directly with “raw” text is the only capability of a legacy text editor.

“New School”"
"IDEs such as VS Code take text editing and writing infrastructure as code to the next level. Built-in linting (syntax and code quality checks) provides immediate feedback. The IDE will proactively, automatically, help the author create quality code. Malformed code with indentation errors is highlighted and underlined in red, directly telling the code author the code has problems and will not compile. VS Code is highly extensible with thousands of extensions to enhance the experience of working with, for example, Python, adding linting for .py files. The editor can be split into vertical and horizontal panels, allowing for direct side-by-side comparison and the ability to work in multiple locations of the same file. VS Code also provides previews that render raw text, such as Markdown or CSV, directly in the editor, providing developers the ability to see what and how their code renders in its final state. One of the most important capabilities of VS Code is that it integrates with Git version and source"
"control. Git commands are abstract- ed from the developer, who can use point-and-click capabilities to work with the version and source control system. VS Code also integrates with Windows Subsystem for Linux (WSL) and provides various terminals and shells, including Bourne Again Shell (bash), Windows terminal, and Ubuntu Linux shell. Remote SSH capabilities, allowing the IDE to connect to remote devices, can be added as an extension. Extensions for Docker and Kubernetes exist, making it easier to work with these platforms in the visually integrated IDE. Regardless of whether the developer uses VS Code or another platform, an IDE is critical and foundational to adopting NetDevOps."
"Git

Git is a free, open-source, and distributed version control system created by Linus Torvalds in 2005 for development of the Linux kernel. Consider Git the glue that holds the NetDevOps lifecycle together, tracking all changes to files using commits. These tracked changes are included in the history of all Git repositories, and changes can be rolled back to any point in time. A distributed version control system, the full repository is cloned to a developer’s local workstation. Git is very lightweight, portable, and inte- grates with VS Code. Version and source control is a key foundational element of auto- mating a network with NetDevOps. Easy to learn yet extremely powerful, Git version- controls the lifecycle of pyATS jobs, tests, intent, and template code. Git commit history makes it easy to understand exactly what changed, under what branch, and by which developer. Artifacts can also be rolled back to a previous point in time using the commit history.

ptg45047941

From the Library of Tos Chaiwong"
"24 Chapter 1: Foundations of NetDevOps

GitHub

GitHub is the largest collection of code, in the form of Git repositories, on the Internet. GitHub, the online central repository, should not be confused with Git, the version and source control software. GitHub offers Internet hosting for version and source control using Git. Both public and private repositories are available, where private reposito- ries require access tokens to contribute to the code. Repositories can be cloned from GitHub locally. GitHub provides mechanisms to create branches from the main branch and the controls to merge code from branches into the main branch. The main branch in NetDevOps should be considered working, valid, and tested code representing the single source of truth. Issues with the code can be tracked and addressed in GitHub. GitHub has many free and paid options for CI/CD such as GitHub Actions."
"GitLab

GitLab is a free, open-source alternative to GitHub that can be hosted privately. GitLab provides CI/CD capabilities and can be used as a central, web-based Git repository system. GitLab offers functionality to collaboratively plan, build, secure, and deploy software as a complete DevOps platform. GitLab can be hosted on-premises or in the cloud. GitLab comes with a built-in wiki, issue tracking, IDE, and CI/CD pipeline fea- tures. GitLab was originally written in Ruby but has since migrated to Go, and it offers extremely high performance as a Git repository platform."
"Structured Data

Networks historically used command-line standard output—unstructured raw command-line output—which limited programmability and automation. Developers had to use regular expressions (RegEx) to tediously transform CLI output into more programmability-friendly structures. Structured data like JSON is also extremely easy to work with using programming languages like Python. One major feature of pyATS is the ability to model and parse commands into structured JSON, providing an easy path to programmability and automation."
"JavaScript Object Notation (JSON)

JSON is a lightweight data-interchange format that is easy for humans to read and write as well as machines to parse and generate. Based on a subset of the JavaScript program- ming language, JSON is programming language independent. JSON is made up of two structures: key-value pairs and ordered lists, known as an array. An object is an unordered set of key-value pairs surrounded by curly braces. Keys are followed by colons, and objects are separated by commas. One of the major features and benefits of using pyATS is that the unstructured Cisco CLI output can be transformed into JSON using either pyATS learn modules or parse libraries, either from the CLI or as part of pyATS jobs. Parsers are covered in detail in Chapter 5, “pyATS Parsers.” Interfaces could be represent- ed by the JSON dictionary of objects demonstrated in Example 1-1.

ptg45047941

From the Library of Tos Chaiwong

The Modern Network Engineer Toolkit 25

Example 1-1 show ip interface brief as JSON

{"
"""interface"": {

""GigabitEthernet1"": {

""interface_is_ok"": ""YES"",

""ip_address"": ""10.10.20.175"",

""method"": ""TFTP"",

""protocol"": ""up"",

""status"": ""up""

},

""GigabitEthernet2"": {

""interface_is_ok"": ""YES"",

""ip_address"": ""172.16.252.21"",

""method"": ""TFTP"",

""protocol"": ""up"",

""status"": ""up""

}

}

}

eXtensible Markup Language (XML)

XML uses tags, similar to Hypertext Markup Language (HTML), to create structured data. XML encodes data that is both human- and machine-readable and is used for both storing and transmitting structured data. XML was designed to be simple, general, and usable across the Internet. Tags in XML represent the data structure and can also contain metadata about the structure. Example 1-2 show the same interface example but in XML instead of JSON.

Example 1-2 show ip interface brief as XML

<?xml version=""1.0"" encoding=""UTF-8"" ?>

<interface>

<GigabitEthernet1>

<interface_is_ok>YES</interface_is_ok>

<ip_address>10.10.20.175</ip_address>"
"<method>TFTP</method>

<protocol>up</protocol>

<status>up</status>

</GigabitEthernet1>

<GigabitEthernet2>

<interface_is_ok>YES</interface_is_ok>

<ip_address>172.16.252.21</ip_address>

ptg45047941

From the Library of Tos Chaiwong

26 Chapter 1: Foundations of NetDevOps

<method>TFTP</method>

<protocol>up</protocol>

<status>up</status>

</GigabitEthernet2>

</interface>"
"YAML Ain’t Markup Language (YAML)

YAML is a recursive acronym that stands for YAML Ain’t Markup Language. YAML is a superset of JSON, and all valid JSON files can be parsed with YAML. YAML is another human- and machine-readable data serialization language, but with minimal syntax. Like Python, YAML uses whitespace indentation to indicate nesting. Much like JSON, YAML uses key-value pair objects, using a colon to separate the key and the paired value, and it also supports lists (or arrays) using hyphens to indicate a list of objects. In the context of pyATS, testbeds (Chapter 4), Clean (Chapter 15), and Blitz (Chapter 19) all require YAML of some form. The interface JSON/XML can be expressed in YAML as shown in Example 1-3.

Example 1-3 show ip interface brief as YAML

---

interface:

GigabitEthernet1:

interface_is_ok: 'YES'

ip_address: 10.10.20.175

method: TFTP

protocol: up

status: up

GigabitEthernet2:

interface_is_ok: 'YES'

ip_address: 172.16.252.21

method: TFTP

protocol: up

status: up"
"YANG

YANG, initially published in October 2010 as Request for Comment (RFC) 6020 and superseded by RFC 7950 in August 2016, is a hierarchical data modeling language. It is used in conjunction with network protocols like NETCONF and RESTCONF to interact with network devices. YANG allows for the modeling of network state, notifications, remote procedure calls (RPCs), and configuration data in protocol-independent XML or JSON formats. To work with YANG models, network automation tools like pyATS can be employed, which facilitate the interaction with YANG-modeled data using Python."
